---
title: "realising making illegal states Unrepresentable"
slug: realising-making-illegal-states-unrepresentable

---

In the [Last Article](https://hashnode.com/post/cmi9yz1xk000002kwdcksh5un), I have discussed the idea of making illegal states not possible. In short : Make your states explicit as types to make the access of some attribute at some point of time not possible. For example: If the order is pending it makes no sense to try to access the `PublishedAt` attribute.

That was primairly discussing the domain modelling itself, but almost any useful application need some sort of Side-Effects, and in Enterprise application, one of the most important side-effects is reading and writing to the database.

So just to get ourself starting with something let’s assume the following basic `Order` modelling where Order either Pending, Approved or Cancelled :

```csharp
internal class PendingOrder
{
    public OrderId Id { get; private set; }
    public DateTime SubmittedAt { get; private set; }
    
    internal PendingOrder(OrderId id, DateTime submittedAt)
    {
        Id = id;
        SubmittedAt = submittedAt;
    }
    
    public static PendingOrder CreateNew(OrderId id)
    {
        return new PendingOrder(id, DateTime.UtcNow);
    }
    
    public ApprovedOrder Approve(string userId)
    {
        return ApprovedOrder.CreateFrom(Id, userId);
    }
    
    public CancelledOrder Cancel(string reason)
    {
        return CancelledOrder.CreateFrom(Id, reason);
    }
    
}

// Domain/Orders/ApprovedOrder.cs
internal class ApprovedOrder
{
    public OrderId Id { get; private set; }
    public string ApprovedBy { get; private set; }
    public DateTime ApprovedAt { get; private set; }
    
    internal ApprovedOrder(OrderId id, string approvedBy, DateTime approvedAt)
    {
        // Maybe also some Domain validation here but not our point of discussion
        Id = id;
        ApprovedBy = approvedBy;
        ApprovedAt = approvedAt;
    }
    
    internal static ApprovedOrder CreateFrom(OrderId id, string userId)
    {
        return new ApprovedOrder(id, userId, DateTime.UtcNow);
    }
    
}

// Domain/Orders/CancelledOrder.cs
public class CancelledOrder
{
    public OrderId Id { get; private set; }
    public string Reason { get; private set; }
    
    private CancelledOrder(OrderId id, string reason)
    {
        Id = id;
        Reason = reason;
    }
    
    internal static CancelledOrder CreateFrom(OrderId id, string reason)
    {
        return new CancelledOrder(id, reason);
    }
    
}
```

# But how to combine them?

Well, there are two options at this point

## Inheritence

If you come from OOP backgroung, you may have directly indentified that OrderId is a fundamentally common thing and that we should raise it to some base class. It would have worked, but this has some problems we are not gonna discuss here in detail.

## Sum types

What does a base `Order` mean without its concrete values??

At any point of time we either have a pending, cancelled or Approved `Order`, and this is exactly what sum types (`enums` in Rust, `std::variant` in C++) is trying to achieve

### Meet the OneOf

I am not gonna discuss the [OneOf](https://github.com/mcintyre321/OneOf) type capabilites here, but it is jsut our way in C# to have a **finite** set of types, as C# has no notion of built-in discriminated Unions.

## So what is wrong with Inheritance?

Well, in my opinion the most important problem is exhaustive pattern matching:

If I am using base type and wanna downcast with some switch statement, the compiler does not make sure I have covered all possible children classes. It is okay if you match at one or two places, otherwise it became error-prone. There are also some another benefits mentioned [here](https://github.com/mcintyre321/OneOf#benefits) briefly.

# Okay Cool, but If relational database’s language is the table not this fancy OneOf.

If you are using C#, it is so likely that you are using EF Core for persistence layer.

One of the debates about EF Core is whether or not to use [Repository](https://martinfowler.com/eaaCatalog/repository.html) pattern, as EF already provides us with all the promises of a Repository already. This is so true! Personally, I tend not to use Repository, but does it make sense in our use case? How can we even convert this very same structure to Relational tables?

## DDD and Clean Architecture promises

One of the most important ideas of DDD is separating the two types of Complexity in software

* Domain (Essential) Complexity : The Modelling of our data itself and the domain rules
    
* Accidental (Technical) Complexity : Talking to the Database, connecting with 3rd-Party and so on
    

So if your modelling makes sense to you (and the team), do not change it to be compatible with some infrastructure. Lmao that infrastructure could itself change in the future.

## Object-Relational-Mapping

ORM frameworks works so well that we forgot what it was doing under the hood: Convert your Object structure that may have inheritence and all that fancy things to just dummy tables with columns.

So we actually do some conversion step each time we access the database, so why not make another conversion step?

### Mapping as a core concept in Clean Architecture

In strict Clean Architecture we already do not use types of some layer at another layer. For example, we usually do not return the domain objects directly but rather a DTO, we do not take API requests directly but rather convert them to Application layer request. So why not make an Domain-Entity Mapping?

I am not gonna discuss how to make that mapping here, because I think if you could follow along you could configure it yourself already. But let’s illustrate with small workflow

1. You save specific things in the database
    
2. Ask The repository later to get you some value with specifc state, so you do not ask about a random order but rather a pending order (You should know the type of the order expected from your API Endpoint)
    
3. The repository converts those specific things to your domain values.
    
4. You work on them, and later ask the repo to save your changes
    
5. The repo converts them to those specific things in step 1.
    

## What did we gain?

Complexity is hidden at one place (The infrastructure) and the Domain layer remains rich and modelled as what we ideally wanted.